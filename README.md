# Orbit
Orbit은 [Doorman](https://github.com/youtube/doorman)과 유사한 글로벌 분산 클라이언트 측 속도 제한 솔루션입니다.
GPU 클러스터, 외부 API, 데이터베이스 등 공유 리소스를 사용하는 클라이언트들의 리소스 사용량을 자발적으로 제한합니다.

## 푸려고 하는 문제
클라이언트들에게 공유 리소스가 할당되어 있는 상태에서, 이들에게 공정하게 리소스를 할당해야합니다.
구체적으로, 아래와 같은 상황을 가진다고 가정합니다.
* Global cap은 strict합니다. 즉, 어떠한 순간에도 클라이언트들이 전체 할당량을 초과해서 요청하는 경우가 없습니다.
* 클라이언트들의 리소스 요구는 계속 달라질 수 있습니다. 순간적으로 클라이언트가 높은 리소스를 요구하더라도,
  글로벌 리소스가 남는다면 허용합니다.

실제 세계의 예시로 생각해보면, 대학의 GPU 클러스터를 생각해볼 수 있습니다.  
한정된 GPU 사용량을 여러 연구소에 분배해야하는데,
어떻게 하면 전체 GPU 클러스터의 처리량을 초과하지 않는 만큼의 요청만 보내도록 전체 연구자들의 클라이언트를 조율할 수 있을까요?

Doorman 프로토콜과 같이 Raft 유사 프로토콜을 이용한 Leader 선출과 중앙에서의 할당량 분배는 이를 해결하는 훌륭한 방법 중 하나이지만,
* 클라이언트들의 전체 할당량을 관리하는 단 하나의 Leader가 생기게 됩니다. (Single Point Of Failure)
  - 재선출 과정을 거치겠지만, Leader가 재선출되고 할당량을 "학습" 하는 동안 전체 클라이언트에 장애가 발생할 것입니다.
* 만약 더 많은 클라이언트들을 처리하기 위해 Doorman 클러스터를 계층적으로 나눠 구축하는 경우 이 문제는 더욱 심각해집니다.
  (예를 들어, 클라이언트 10개를 묶어 L1 Doorman, L1을 10개씩 묶어 L2 Doorman...)

이러한 문제를 문제를 해결하기 위해 **Orbit** 프로토콜을 제안합니다.

## Orbit Protocol
Orbit은 Doorman과 다른 방법으로 전체 레이트리밋 문제를 해결합니다.

* 모든 노드를 링모양으로 연결합니다. 각각의 노드는 바로 이전 노드, 바로 다음 노드와 통신하게 됩니다.
* 하나의 마스터를 선출하는 대신, 각 노드가 매 에포크마다 할당량을 분배받고, 제약 조건 내에서 원하는 만큼 사용합니다.
* 자신이 할당받은 사용량 중 "남은" 부분은 유효 에포크와 함께 다음 노드에 전달됩니다.
* 다음 노드는 할당량을 사용할 때 우선 이전 노드에서 할당 받은 사용량을 먼저 사용하고, 또 남은만큼을 다음 노드에 전송합니다.
* 각 에포크는 수신 페이즈와 송신 페이즈로 구분됩니다. 수신 페이즈에서 이전 노드로부터 정보를 받아서 현재 사용량을 가져간 후, 송신 페이즈에서 다음 노드에 정보를 전송하게 됩니다.

## 예상되는 문제 & 해결법
* **바로 이전 노드가 사용량을 독점하면, 다음 노드는 최대 사용량이 매우 낮아진다** :  
  우선 각 노드가 남은 용량을 최대 `QUOTE%` 만큼만 사용할 수 있게 하여 다음 노드가 사용할 수 있는 최소 수치를 보장합니다.
  그리고, 현재 "필요 사용량"을 "실제 사용량"과 함께 기록하여 다음 노드에 넘깁니다.
  이렇게 되면 각 노드가 다른 모든 노드의 이전 바퀴 필요 사용량을 알 수 있게 됩니다. 자신의 필요량과 다른 노드의 필요량에 맞춰 현재 에포크에서 가져가는 할당량을 적절히 조정하는 방식으로 문제를 해결합니다.
* **특정 노드가 다운되거나 네트워크가 단절되면 어떻게 되는가?** :
  각 트랜잭션은 전송이 충분히 안정적이라고 가정합니다. 즉, 정상적으로 요청이 전송되지 않은 경우 송신자와 수신자 모두 알 수 있습니다 (TCP)
  - 이전 노드로부터 이번 사용량을 받지 못하고 있는 경우, 노드는 최대 할당량을 Y = `(전체에포크할당량/노드개수)*QUOTE%`로 맞추고 다음 노드에 전파 실패와 함께 사용량을 전송합니다.
  - 다음 노드로 사용량을 보내고 못하고 있는 경우, 건너뛰고 그 다음 노드에 전송을 시도합니다. 그것도 실패한 경우 다다음 노드, 다다다음 노드... 에 전송을 시도합니다.
  - 이전 노드로부터 사용량을 받지 못했더라도, 전전 노드에서 사용량을 받았다면 이전 노드는 Y 만큼만 할당량을 이용했다고 가정하고 계속 계산합니다.
  - 위 세 과정을 통해 어떤 한 노드에서 제대로 이전 노드 값을 받고 있지 못하거나, 다음 노드로 전파하지 못하고 있을 경우 global cap을 넘지 않으면서 모든 노드가 적절한 사용량을 받도록 허용할 수 있습니다.
* **에포크 사이사이에 요청을 보내지 못하는 공백이 생긴다.** :
  - 각 노드는 이전 노드에서 아무런 정보를 받지 못하더라도 `(전체에포크할당량/노드개수)*QUOTE%` 만큼의 사용량은 항상 사용할 수 있음을 보장받을 수 있습니다.
  - 에포크 사이의 공백 시간동안은 이만큼의 사용량을 사용할 수 있다고 가정하고 처리합니다. 이 사용량을 넘어서는 요청의 경우에는 이전 노드로부터 정보가 올때까지 홀드합니다.
 
## 프로토콜의 한계
- **레이트리밋 윈도우의 최소 시간이 `에포크시간*노드개수`로 제한됩니다.** 즉, Orbit은 긴 기간 (분~시간단위) 동안의 평균 사용량이 일정 이하임을 보장할 수 있지만, 짧은 시간동안 요청이 몰려들어오는 것은 방지할 수 없습니다.
  이는 분산 처리 시스템의 한계로, 각 노드가 요청을 보내기 전에는 모든 노드의 현재 정보를 가질 수 없으므로, Orbit 시스템만으로는 이 문제를 해결할 수 없습니다.  
  이를 해결하기 위해서 각 노드에서 로컬 레이트리밋 알고리즘을 2차적으로 적용해 순간적인 burst를 방지할 수 있도록 보완이 필요합니다.
  
## Resources
* [Doorman - Global Distributed Client Side Rate Limiting](https://github.com/youtube/doorman)
* [Rethinking HTTP API Rate Limiting: A Client-Side Approach](https://arxiv.org/abs/2510.04516)
* [High-throughput distributed rate limiter](https://engineering.linecorp.com/en/blog/high-throughput-distributed-rate-limiter)
